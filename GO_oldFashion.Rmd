---
title: "GO_oldFashion"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r package loading}
library(tidyverse)
library(magrittr)
library(biomaRt)
library(parallel)
library(GO.db)
library(annotate)
library(scales)
nCores <- min(detectCores() - 1, 12)
options(stringsAsFactors = FALSE)
```

```{r download gene with go info from ensembl}
# To choose BioMart database and construct information needed
listMarts(host="plants.ensembl.org")
m <- useMart("plants_mart", dataset="athaliana_eg_gene", host="plants.ensembl.org")
# listDatasets(m) # check plants info version 
# attributes <- listAttributes(m) # Choose data types you want to download

go <- getBM(attributes=c("ensembl_gene_id","go_id"), mart=m)
colnames(go) <- c("GeneID", "GO_terms")
```

```{r collect GO for genes}
# attach go terms to each gene
gene2GO <- go %>%
  filter(!is.na(GO_terms)) %>%
  distinct(GeneID,GO_terms) %>% 
  split(f = .$GeneID) %>%
  mclapply(function(x){
    unique(x$`GO_terms`)
  }, mc.cores = nCores)
# Remove any with no GO terms
gene2GO <- gene2GO[vapply(gene2GO, length, numeric(1)) > 0]
```

```{r build GO tree}
# Collect all the ancestor terms for each GO term
goAncestors <- c(
  as.list(GOBPANCESTOR),
  as.list(GOCCANCESTOR),
  as.list(GOMFANCESTOR)
)
# Define the Root nodes
rootGO <- list(
  BP = "GO:0008150",
  CC = "GO:0005575",
  MF = "GO:0003674"
)
# Define the terms with <= 1 step back to the root nodes
firstLevelGO <- list(
  BP = c(rootGO$BP, get(rootGO$BP, GOBPCHILDREN)),
  CC = c(rootGO$CC, get(rootGO$CC, GOCCCHILDREN)),
  MF = c(rootGO$MF, get(rootGO$MF, GOMFCHILDREN))
) %>%
  lapply(unique)
# Define the terms with <= 2 steps back to the root nodes
secondLevelGO <- list(
  BP = c(firstLevelGO$BP, lapply(firstLevelGO$BP, get, GOBPCHILDREN)),
  CC = c(firstLevelGO$CC, lapply(firstLevelGO$CC, get, GOCCCHILDREN)),
  MF = c(firstLevelGO$MF, lapply(firstLevelGO$MF, get, GOMFCHILDREN))
) %>%
  lapply(unlist) %>%
  lapply(unique) %>%
  lapply(function(x){x[!is.na(x)]})
# Define the terms with <= 3 steps back to the root nodes
thirdLevelGO <- list(
  BP = c(secondLevelGO$BP, lapply(secondLevelGO$BP, get, GOBPCHILDREN)),
  CC = c(secondLevelGO$CC, lapply(secondLevelGO$CC, get, GOCCCHILDREN)),
  MF = c(secondLevelGO$MF, lapply(secondLevelGO$MF, get, GOMFCHILDREN))
) %>%
  mclapply(unlist, mc.cores = nCores) %>%
  mclapply(unique, mc.cores = nCores) %>%
  mclapply(function(x){x[!is.na(x)]}, mc.cores = nCores)
# Expand so each gene now has all parent terms correctly assigned and also removing GO terms which are 3rd level or below
gene2GO %<>% mclapply(function(x){
  unlist(goAncestors[x]) %>% 
    unique %>%
    setdiff(unlist(thirdLevelGO)) %>% # This is now one step deeper into the go terms
    # setdiff(unlist(secondLevelGO)) %>%  # This is the original method
    setdiff("all")
}, mc.cores = nCores)
# Remove any with no GO terms again
gene2GO <- gene2GO[vapply(gene2GO, length, numeric(1)) > 0]

# attach gene with each go term for later trackgo back to genes
go2Gene <- lapply(names(gene2GO), function(x){
  tibble(GeneID = x,
         GO = gene2GO[x] %>% unlist())
}) %>% bind_rows() %>% 
  distinct(GeneID,GO) %>%
  split(f = .$GO) %>%
  lapply(function(x){
    x[["GeneID"]]
  }) 

goSummaries <- url("https://uofabioinformaticshub.github.io/summaries2GO/data/goSummaries.RDS") %>%
  readRDS()
```

```{r DEgene to collect go}
#---------input DE gene----------#
genes <- DGEs$gad1CS
genes$GeneID %>%
   length()
genes$GeneID %>%
  intersect(names(gene2GO)) %>% length()
#--------------------------------#

All_GO <- lapply(unique(genes$expression), function(r){
  Data <- genes %>% 
    filter(expression == r)
  DEgenes <- Data$GeneID %>%
    intersect(names(gene2GO))
  deGenes2GO <- gene2GO[DEgenes] # a
  notDEGenes2GO <- gene2GO[setdiff(names(gene2GO), DEgenes)] # b
  # genome wild protein coding gene except genes in the DEgenes as background
  deGO <- unlist(deGenes2GO) %>% 
    table %>%
    as.data.frame() %>%
    set_names(c("Term", "DECount")) %>%
    mutate(notDECount = table(unlist(notDEGenes2GO))[Term],
           notDECount = as.vector(notDECount)) %>%
    as_tibble() %>%
    filter(DECount > 1) %>% # filter de count more than 1 for each go terms
    arrange(Term) %>%
    droplevels()
  nDE <- length(deGenes2GO)
  nNotDE <- length(notDEGenes2GO)
  deGO %>%
    split(f = .$Term) %>%
    lapply(function(df){
      mat <- matrix(c(df$DECount[1], df$notDECount[1],
                      nDE - df$DECount[1], nNotDE - df$notDECount[1]),
                    nrow = 2) %>% 
        set_colnames(c("Genes With GO Term", "Genes Without GO Term")) %>% 
        set_rownames(c("Genes of Interest", "Control Genes"))
      ft <- fisher.test(mat)
      mutate(df,
             Expected = nDE * df$notDECount[1] / nNotDE,
             #Expected = percent(df$notDECount / nNotDE), # The percentage of genes with the term in the control set
             # Observed = percent(df$DECount / nDE), # The percentage of genes with the term in the set of interest
             p = ft$p.value)
    }) %>%
    bind_rows() %>%
    mutate(adjP = p.adjust(p, "bonferroni"),
           FDR = p.adjust(p, "BY")) %>%
    arrange(p) %>%
    mutate(Description = Term(as.character(Term)),
           regulation = r) %>%
    left_join(goSummaries, by = c("Term" = "id")) %>%
    filter(DECount > Expected) %>% # consider the t.test is two-sided
    dplyr::select(Term, Description, shortest_path, terminal_node, everything())
}) %>% 
  bind_rows()


```

