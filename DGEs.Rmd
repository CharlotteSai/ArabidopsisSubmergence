---
title: "Arabidopsis_mutatnts_col"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(magrittr)
library(edgeR)
```

```{r data clean up}
# load and clean up gene counts
geneCounts <- read_delim("4_Counts/Ying_Submergence_batch1_final.txt", 
                         delim = "\t", 
                         comment = "#") %>% 
  column_to_rownames("Geneid")
colnames(geneCounts) %<>% str_remove("../3_BAM/") %>% str_remove(".STARAligned_TAIR10.sortedByCoord.bam")

# crate meta data
meta <- tibble(sample = colnames(geneCounts),
               submergence = str_extract(sample,"cont|sub"), 
               genotype = str_extract(sample,".+(?=-(cont|sub))"),
               reps = str_extract(sample,"(?<=(cont|sub)-).+"),
               group = paste(genotype, submergence, sep = "_") # this info will fill to 'group' as col name match 'group' pram in DGEList() and converting to a single factor Exp
)

# because I am only focus on genotype difference in control condition, Thus I only use data in control condition
meta %<>% 
  filter(submergence == "cont") %>%
  select(-group, -submergence)
geneCounts %<>% select(meta$sample)

# construct DGElist, filtering and normalize RNA composition
countList <- DGEList(counts = geneCounts,
                     group = meta$genotype) 

keep <- filterByExpr(countList)
# By default, the function keeps genes with about 10 read counts or more in a minimum number of samples, where the number of samples is chosen according to the minimum group sample size. The actual filtering uses CPM values rather than counts in order to avoid giving preference to samples with large library sizes. For this dataset, the median library size is about 18 million and 10/18 approx. 0.55, so the filterByExpr function keeps genes that have a CPM of 0.55 or more in at least 4 samples.
table(keep)
countList <- countList[keep,, keep.lib.sizes=FALSE] %>% 
  calcNormFactors()

# set control group as reference 
countList$samples$group <-  relevel(countList$samples$group, ref = "Col")
```

```{r mds}
# visualize sample clustering, alternatively PCA can do the job
mds <- plotMDS(countList, method="bcv", col=as.numeric(countList$samples$group))
# make it easy to change appearance 
mds %>%
  extract(c(5,6)) %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  left_join(meta) %>%
  ggplot(aes(x = x, y = y)) +
  geom_point(aes(colour  = genotype), 
             size = 3) +
  theme_bw() +
  labs(x = "BCV distance 1",
       y = "BCV distance 2")
```

```{r estimating dispersions}
# if with multiple factors, dispersion needs to be estimated with specified design matrix (see section 2.10.2 in edgeR user's guide updated in 21 Oct. 2019)
counts_Disp <- estimateDisp(countList)
plotBCV(counts_Disp)
```

```{r model fitting and contrast making}
# contract a design matrix with baseline control
designMat <- model.matrix(~ 0 + group, data = countList$samples)
colnames(designMat) <- levels(countList$samples$group)

# fit to model
fit <- glmQLFit(counts_Disp, design = designMat)

# make contrast easy to follow
myContrast <- makeContrasts(gad1CS = gad1CS - Col,
                            gad1SALK = gad1SALK - Col,
                            gad21 = gad21 - Col,
                            gad1245 = gad1245 - Col,
                            gad2OEB33 = gad2OEB33 - Col,
                            pop28 = pop28 - Col,
                            gad1245_special = gad1245 - (gad21 + Col)/2, 
                            # gad1245 diff compare to wt apart from the diff form gad21
                            levels = designMat)
```

```{r find DE genes and corisponding vocano plots}
# run a loop to go through test by each genotype compare to wt (Col)
deRes <- lapply(colnames(myContrast), function(i){
  qlf <- glmQLFTest(fit, contrast = myContrast[,i])
  qlf$table %>% 
  rownames_to_column("GeneID") %>% 
  mutate(adj.p = p.adjust(PValue, method = "BH"),
         comparison = ifelse(i != "gad1245_special",
                             paste0(i,"-wt"),
                             i))
})
names(deRes) <- colnames(myContrast)

vocanoPlots <- lapply(colnames(myContrast), function(i){
  lim = max(abs(deRes[[i]]$logFC))
  deRes[[i]] %>% 
  mutate(expression = ifelse(adj.p < 0.05 & abs(logFC) >= 1, 
                             ifelse(logFC > 1 ,'Up','Down'),
                             'Stable')) %>% 
  ggplot(aes(x = logFC, 
             y = -log10(adj.p), 
             colour = expression)) +
  geom_point(alpha = 0.4, size = 3.5) +
  scale_color_manual(values=c("blue", "grey","red"))+
  xlim(c(-lim - 0.5,
         lim + 0.5)) +
  geom_vline(xintercept = c(-1,1),
             lty=4,col="black",
             lwd=0.8) +
  geom_hline(yintercept = -log10(0.05),
             lty=4,col="black",
             lwd=0.8) +
  labs(x="log2(fold change)",
       y="-log10 (adj.p-value)")  +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5), 
        legend.position="right", 
        legend.title = element_blank())
})
names(vocanoPlots) <- colnames(myContrast)
```

```{r prepare DGEs for GO}
# the filtering applied with both adj.p and logFC
DGEs <- lapply(names(deRes), function(i){
  deRes[[i]] %>% 
  filter(adj.p < 0.05 & abs(logFC) >= 1) %>% 
  mutate(expression = ifelse(logFC > 1 ,'Up','Down'))
})
names(DGEs) <- names(deRes)

# see overlap between gad21, gad1245 and gad1245 special
geno <- names(deRes) %>% str_subset("gad21|gad1245")
lapply(geno, function(g){
  deRes[[g]] %>% 
  mutate(sig = ifelse(adj.p < 0.05 & abs(logFC) >= 1, 
                       1,0)) %>% 
    column_to_rownames("GeneID") %>% 
    dplyr::select(sig) %>% 
    set_names(g)
}) %>% 
  as.data.frame() %>%
  vennDiagram(circle.col=c("turquoise", "salmon","slateblue"))

# save.image("~/Box/Bioinfo/ArabidopsisSubmergence/DGEs.RData")
```

